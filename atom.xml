<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shyer31.github.io</id>
    <title>Shyer</title>
    <updated>2021-07-30T12:26:05.186Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shyer31.github.io"/>
    <link rel="self" href="https://shyer31.github.io/atom.xml"/>
    <subtitle>growing apples</subtitle>
    <logo>https://shyer31.github.io/images/avatar.png</logo>
    <icon>https://shyer31.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Shyer</rights>
    <entry>
        <title type="html"><![CDATA[Spring完全注解式开发 - 01 - demo]]></title>
        <id>https://shyer31.github.io/post/spring-anno-01-demo/</id>
        <link href="https://shyer31.github.io/post/spring-anno-01-demo/">
        </link>
        <updated>2021-07-29T10:15:22.000Z</updated>
        <summary type="html"><![CDATA[<p>学完《Spring完全注解式开发-01》，来写个demo放到tomcat上跑一下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>学完《Spring完全注解式开发-01》，来写个demo放到tomcat上跑一下。</p>
<!--more-->
<h2 id="环境">环境</h2>
<ul>
<li>
<p>开发工具</p>
<p><code>IntelliJ IDEA</code></p>
</li>
<li>
<p>服务器</p>
<p><code>Tomcat 9</code></p>
</li>
</ul>
<h2 id="搭建">搭建</h2>
<h3 id="目录结构">目录结构</h3>
<figure data-type="image" tabindex="1"><img src="https://shyer31.github.io/post-images/1627553779285.png" alt="" loading="lazy"></figure>
<h3 id="spring配置">Spring配置</h3>
<pre><code class="language-java">@ComponentScan(
        basePackages = {&quot;com.shyer&quot;},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION,  classes = {Controller.class})
        }
)
public class SpringConfig {
}
</code></pre>
<p>这里没有加<code>@Configuration</code>，待会说明。</p>
<h3 id="springmvc配置">SpringMVC配置</h3>
<pre><code class="language-java">@EnableWebMvc
@ComponentScan(
        basePackages = {&quot;com.shyer&quot;},
        includeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})
        },
        useDefaultFilters = false
)
public class SpringMvcConfig {
}
</code></pre>
<p>这里没有加<code>@Configuration</code>，待会说明。</p>
<h3 id="web配置">Web配置</h3>
<pre><code class="language-java">public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }

    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{&quot;/&quot;};
    }
}
</code></pre>
<p>这个配置就相当于以前配置<code>web.xml</code>了，将<code>Spring</code>和<code>SpringMVC</code>的配置和<code>servlet</code>结合起来，在项目启动的时候进行初始化。因为我们将配置交给了servlet管理了，所以<code>@Configuration</code>在上面是可以不加的。</p>
<p>另外我们这里只是继承了<code>AbstractAnnotationConfigDispatcherServletInitializer</code>就可以了，不再像以前那样配置web.xml了，我们的demo里也是没有web.xml的，根本原因就是servlet不知道啥时候起用起了<code>SPI</code>了，servlet对外提供了<code>ServletContainerInitializer</code>这个SPI接口，Spring的<code>SpringServletContainerInitializer</code>实现了该接口，并提供了<code>WebApplicationInitializer</code>接口供Spring使用者配置，而<code>AbstractAnnotationConfigDispatcherServletInitializer</code>就是<code>WebApplicationInitializer</code>的实现。</p>
<h3 id="测试代码">测试代码</h3>
<pre><code class="language-java">@RestController
public class HelloController {
    @Autowired
    private HelloService helloService;

    @RequestMapping(&quot;/hello&quot;)
    public String hello() {
        return helloService.hello();
    }
}


@Service
public class HelloService {
    public String hello() {
        return &quot;Hello World&quot;;
    }
}
</code></pre>
<p>部署到tomcat中，运行页面访问就行了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring完全注解式开发 - 01]]></title>
        <id>https://shyer31.github.io/post/spring-anno-01/</id>
        <link href="https://shyer31.github.io/post/spring-anno-01/">
        </link>
        <updated>2021-07-29T09:09:14.000Z</updated>
        <summary type="html"><![CDATA[<p>基于Spring5的开发学习，因为个人喜好，不用传统的<code>xml</code>配置方式，而是使用<code>Annotation-based</code>方式进行配置开发。</p>
]]></summary>
        <content type="html"><![CDATA[<p>基于Spring5的开发学习，因为个人喜好，不用传统的<code>xml</code>配置方式，而是使用<code>Annotation-based</code>方式进行配置开发。</p>
<!--more-->
<h2 id="spring配置类">Spring配置类</h2>
<h3 id="基本配置">基本配置</h3>
<ul>
<li>
<p>新建类<code>SpringConfig</code>作为<code>Spring</code>的配置</p>
<pre><code class="language-java">@Configuration
public class SpringConfig {
}
</code></pre>
</li>
<li>
<p>测试</p>
<p><strong>测试代码</strong></p>
<pre><code class="language-java">@Test
public void test01() {
  // 使用AnnotationConfigApplicationContext，也就是注解配置的应用上下文
  ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
  Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);
}
</code></pre>
<p><strong>测试结果</strong></p>
<pre><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
springConfig
</code></pre>
<p>可以看到spring容器已经扫描到了bean，并放入容器了。因为<code>@Configuration</code>这个注解本身也是<code>@Component</code>所以也被纳入了Spring容器中。但此时，Spring容器并没有扫描我们自己的包，只是将自身的几个Bean纳入了IOC中。</p>
</li>
</ul>
<h3 id="包扫描">包扫描</h3>
<ul>
<li>
<p>为配置类增加<code>@ComponentScan</code>注解，并设置<code>basePackages</code>，这样Spring会对<code>basePackages</code>中的包进行扫描，并将所有的组件放到IOC容器中，包括<code>@Component</code>，<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>，<code>@Configuration</code></p>
<pre><code class="language-java">@Configuration
@ComponentScan(
        basePackages = {&quot;com.shyer&quot;}
)
public class SpringConfig {
}
</code></pre>
<p><code>@ComponentScan</code>的属性<code>includeFilters</code>和<code>excludeFilters</code>可以用来自定义扫描的组件。</p>
<ul>
<li>
<p><code>includeFilters</code>：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(
        basePackages = {&quot;com.shyer&quot;},
        includeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})
        },
        useDefaultFilters = false
)
public class SpringConfig {
}
</code></pre>
<p>就会只扫描<code>com.shyer</code>包下<code>@Controller</code>注解类，注意这里还要设置一下<code>useDefaultFilters</code>为<code>false</code>，因为默认的<code>Filter</code>就是会扫描所有组件的。</p>
<ul>
<li>
<p>测试</p>
<p>测试代码</p>
<pre><code class="language-java">/**
 目录结构(根目录: com.shyer)
  -- config
    |-- SpringConfig.java
  -- controller
    |-- HelloController.java（@RestController）
  -- service
    |-- HelloService.java（@Service）
   */
@Test
public void test01() {
    ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
    Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);
}
</code></pre>
<p>测试结果</p>
<pre><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
springConfig
helloController
</code></pre>
<p>可以看到，只扫描出了<code>HelloController</code>，<code>HelloService</code>没有扫描到。</p>
</li>
</ul>
</li>
<li>
<p><code>excludeFilters</code></p>
<pre><code class="language-java">@Configuration
@ComponentScan(
        basePackages = {&quot;com.shyer&quot;},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION,  classes = {Controller.class})
        }
)
public class SpringConfig {
}
</code></pre>
<p>会扫描<code>com.shyer</code>包下的的所有组件（因为<code>useDefaultFilters</code> 默认为<code>true</code>），除了<code>@Controller</code>组件。</p>
<ul>
<li>
<p>测试</p>
<p>测试代码</p>
<pre><code class="language-java">/**
 目录结构(根目录: com.shyer)
  -- config
    |-- SpringConfig.java
  -- controller
    |-- HelloController.java（@RestController）
  -- service
    |-- HelloService.java（@Service）
   */
@Test
public void test01() {
    ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
    Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);
}
</code></pre>
<p>测试结果</p>
<pre><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
springConfig
helloService
</code></pre>
<p>可以看到，只扫描了<code>HelloService</code>。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>发散一小下</p>
<p><code>includeFilters</code>可以配置扫描组件，那可不可以扫描我自己写的注解用在的类呢，试一下：</p>
<pre><code class="language-java">/**
  目录结构(根目录: com.shyer)
    -- bean
      |-- MyAnno.java
      |-- MyTest.java
  */

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MyAnno {
}

@MyAnno
public class MyTest {
}
</code></pre>
<p>将注解<code>MyAnno</code>添加到<code>includeFilters</code>中：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(
        basePackages = {&quot;com.shyer&quot;},
        includeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class, MyAnno.class})
        },
        useDefaultFilters = false
)
public class SpringConfig {
}
</code></pre>
<ul>
<li>
<p>测试</p>
<pre><code class="language-java">@Test
public void test01() {
  ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
  Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);
}
</code></pre>
<p>输出结果：</p>
<pre><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
springConfig
myTest
helloController
</code></pre>
<p>可以看到，<code>MyTest</code>也被扫描进了IOC容器了</p>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原子类]]></title>
        <id>https://shyer31.github.io/post/atomics/</id>
        <link href="https://shyer31.github.io/post/atomics/">
        </link>
        <updated>2021-07-28T10:48:02.000Z</updated>
        <summary type="html"><![CDATA[<p>本文为学习汪文君《Java 高并发编程详解 - 深入理解并发核心库》的笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文为学习汪文君《Java 高并发编程详解 - 深入理解并发核心库》的笔记</p>
<!--more-->
<p>JDK1.5之前，为了确保在多线程下对某基本数据类型或引用类型数据运算的原子性，必须依赖<code>synchronized</code>关键字，JDK1.5之后，JDK官方为开发者提供了原子类型的工具集，比如<code>AtomicInteger</code>，<code>AtomicBoolean</code>等。这些原子类型都是Lock-Free及线程安全的。</p>
<p>其实通过测试对比，监控线程状态可以发现，原子类型比如<code>AtomicInteger</code>的线程基本处于<code>RUNNABLE</code>状态，没有<code>BLOCKED</code>状态，而<code>synchronized</code>关键字则相反，<code>BLOCKED</code>的状态占比很高。</p>
<h2 id="atomicinteger">AtomicInteger</h2>
<p><code>AtomicInteger</code>和<code>Integer</code>一样，都继承了<code>Number</code>类。</p>
<p><code>AtomicInteger</code>的内部有一个被<code>volatile</code>关键字修饰的成员变量<code>value</code>：</p>
<pre><code class="language-java">private volatile int value;
</code></pre>
<p><code>AtomicInteger</code>提供的所有原子操作方法都是针对该变量进行操作的。</p>
<ul>
<li>
<p>数字增操作</p>
<ul>
<li>
<p><code>int getAndIncrement()</code></p>
<p>返回当前<code>int</code>类型的<code>value</code>值，然后对<code>value</code>进行自增运算。</p>
<p>单线程效果同<code>value++</code></p>
</li>
<li>
<p><code>int incrementAndGet()</code></p>
<p>直接返回自增后的<code>value</code>。</p>
<p>单线程效果同<code>++value</code></p>
</li>
</ul>
</li>
<li>
<p>数字减操作</p>
<ul>
<li>
<p><code>int getAndDecrement()</code></p>
<p>返回当前<code>int</code>类型<code>value</code>值，然后对<code>value</code>进行自减运算。</p>
<p>单线程效果同<code>value--</code></p>
</li>
<li>
<p><code>int decrementAndGet()</code></p>
<p>直接返回自减后的<code>value</code>。</p>
<p>单线程效果同<code>--value</code></p>
</li>
</ul>
</li>
<li>
<p>数字更新操作</p>
<ul>
<li>
<p><code>boolean compareAndSet(int expect, int update)</code></p>
<p>原子性更新<code>value</code>的值，<code>expect</code>代表期望的当前<code>value</code>值，<code>update</code>代表需要设置的新值。</p>
<p>如果当前的<code>value</code>与<code>expect</code>相同，则设置<code>value</code>为<code>update</code>，返回<code>true</code>。</p>
<p>如果当前的<code>value</code>与<code>expect</code>不同，则不修改<code>value</code>的值，直接返回<code>false</code>。</p>
</li>
<li>
<p><code>int getAndAdd(int delta)</code></p>
<p>原子性更新<code>value</code>的值，更新后的<code>value</code>为<code>value</code>和<code>delta</code>的和，方法返回的是<code>value</code>更新前的值。</p>
</li>
<li>
<p><code>int addAndGet(int delta)</code></p>
<p>该方法与<code>getAndAdd(int delta)</code>一样，只不过返回的是<code>value</code>更新后的值。</p>
</li>
</ul>
</li>
<li>
<p>AtomicInteger与函数式接口</p>
<p>JDK1.8之后增加了函数式接口，<code>AtomicInteger</code>也提供了对函数式接口的支持。</p>
<ul>
<li>
<p><code>int getAndUpdate(IntUnaryOperator updateFunction)</code></p>
<p>原子性更新<code>value</code>的值，入参为<code>IntUnaryOperator</code>接口，返回值为<code>value</code>更新前的值。</p>
<p><code>IntUnaryOperator</code> :</p>
<pre><code class="language-java">@FunctionalInterface
public interface IntUnaryOperator {
    /**
     * Applies this operator to the given operand.
     *
     * @param operand the operand
     * @return the operator result
     */
    int applyAsInt(int operand);
}
</code></pre>
<p>使用示例 :</p>
<pre><code class="language-java">AtomicInteger ai = new AtomicInteger(10);
assert ai.getAndUpdate(x -&gt; x + 2) == 10;
assert ai.get() == 12;
</code></pre>
</li>
<li>
<p><code>int updateAndGet(IntUnaryOperator updateFunction)</code></p>
<p>与<code>int getAndUpdate(IntUnaryOperator updateFunction)</code>类似，只是返回值为<code>value</code>更新后的值。</p>
</li>
<li>
<p><code>int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction)</code></p>
<p>原子性更新<code>value</code>值，返回<code>value</code>更新前的值</p>
<pre><code class="language-java">AtomicInteger ai = new AtomicInteger(10);
// left = 10, right = 5
ai.getAndAccumulate(5, (left, right) -&gt; left + right - 1);
assert ai.get() == 14;
</code></pre>
</li>
<li>
<p><code>int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction)</code></p>
<p>与<code>int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction)</code>类似，只是返回<code>value</code>更新后的值。</p>
</li>
</ul>
</li>
<li>
<p>其他方法</p>
<ul>
<li>
<p><code>void set(int newValue)</code></p>
<p>修改<code>value</code>的值为<code>newValue</code></p>
</li>
<li>
<p><code>void lazySet(int newValue)</code></p>
<p><code>volatile</code>将<code>value</code>强制刷到主内存中，归功于<code>volatile</code>底层的内存屏障，它会在设置<code>value</code>的时候创建hanppens-before edges，而<code>lazySet</code>是通过<code>Unsafe</code>根据<code>value</code>初始化时计算出来的偏移量找到<code>value</code>的地址，然后调用本地方法进行修改，这样就不会创建hanppens-before edges，但也因此<code>lazySet</code>不能保证<code>value</code>的立即可见。PS：底层的东西其实还不太懂，后续研究，单独写一篇。</p>
<figure data-type="image" tabindex="1"><img src="https://shyer31.github.io/post-images/1627469432064.png" alt="" loading="lazy"></figure>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CountDownLatch和CyclicBarrier]]></title>
        <id>https://shyer31.github.io/post/countdownlatch/</id>
        <link href="https://shyer31.github.io/post/countdownlatch/">
        </link>
        <updated>2021-07-28T01:16:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="countdownlatch">CountDownLatch</h2>
<h2 id="cyclicbarrier">CyclicBarrier</h2>
]]></content>
    </entry>
</feed>
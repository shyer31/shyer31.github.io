<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shyer31.github.io</id>
    <title>Shyer</title>
    <updated>2021-08-19T11:18:50.377Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shyer31.github.io"/>
    <link rel="self" href="https://shyer31.github.io/atom.xml"/>
    <subtitle>growing apples</subtitle>
    <logo>https://shyer31.github.io/images/avatar.png</logo>
    <icon>https://shyer31.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Shyer</rights>
    <entry>
        <title type="html"><![CDATA[SpringMVC 注解配置使用]]></title>
        <id>https://shyer31.github.io/post/springmvc-anno-config/</id>
        <link href="https://shyer31.github.io/post/springmvc-anno-config/">
        </link>
        <updated>2021-08-19T11:17:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="web配置类">WEB配置类</h2>
<blockquote>
<p>取代web.xml</p>
</blockquote>
<pre><code class="language-java">public class MyWebApplicationInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
    /**
     * Spring配置
     */
    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return null;
    }

    /**
     * SpringMVC配置
     */
    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    /**
     * DispatcherServlet拦截路径
     */
    @Override
    protected String[] getServletMappings() {
        return new String[]{&quot;/&quot;};
    }
}
</code></pre>
<h2 id="编码">编码</h2>
<pre><code class="language-java">public class MyWebApplicationInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Filter[] getServletFilters() {
        CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter();
        encodingFilter.setEncoding(&quot;UTF-8&quot;);
        encodingFilter.setForceResponseEncoding(true);

        HiddenHttpMethodFilter methodFilter = new HiddenHttpMethodFilter();

        return new Filter[]{encodingFilter, methodFilter};
    }
}
</code></pre>
<h2 id="mvc配置类">MVC配置类</h2>
<h3 id="方式一">方式一</h3>
<pre><code class="language-java">@EnableWebMvc
@ComponentScan(
	basePackages = &quot;com.shyer.controller&quot;
)
public class WebConfig {
  
}
</code></pre>
<h3 id="方式二">方式二</h3>
<blockquote>
<p>实现 <code>WebMvcConfigurer</code> 接口。可以实现该接口的方法实现扩展配置。</p>
</blockquote>
<pre><code class="language-java">@EnableWebMvc
@ComponentScan(
        basePackages = {&quot;com.shyer.controller&quot;, &quot;com.shyer.exception&quot;}
)
public class SpringMvcConfig implements WebMvcConfigurer {
  
}
</code></pre>
<h3 id="方式三">方式三</h3>
<blockquote>
<p>继承 <code>WebMvcConfigurationSupport</code> 方法，这种方式可以不用配置 <code>@EnableWebMvc</code> 注解。可以重写该类的方法实现扩展配置。</p>
</blockquote>
<pre><code class="language-java">@ComponentScan(
        basePackages = {&quot;com.shyer.controller&quot;, &quot;com.shyer.exception&quot;}
)
public class SpringMvcConfig extends WebMvcConfigurationSupport {
}
</code></pre>
<h2 id="异常处理器">异常处理器</h2>
<h3 id="方式一-2">方式一</h3>
<pre><code class="language-java">@ControllerAdvice
public class ExceptionController {
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public String handle(Exception ex, Model model) {
        ex.printStackTrace();
        return &quot;error&quot;;
    }
}
</code></pre>
<pre><code class="language-java">@EnableWebMvc
@ComponentScan(
        basePackages = {&quot;com.shyer.controller&quot;, &quot;com.shyer.exception&quot;}
)
public class SpringMvcConfig {
  
}
</code></pre>
<h3 id="方式二-2">方式二</h3>
<pre><code class="language-java">@EnableWebMvc
@ComponentScan(
        basePackages = {&quot;com.shyer.controller&quot;, &quot;com.shyer.exception&quot;}
)
public class SpringMvcConfig implements WebMvcConfigurer {
    /**
     * 异常处理
     */
    @Override
    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) {
        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();
        
        // 异常对应的错误页面
        Properties properties = new Properties();
        properties.setProperty(ArithmeticException.class.getName(), &quot;error&quot;);
        exceptionResolver.setExceptionMappings(properties);
        // 异常信息在request域中的key名
        exceptionResolver.setExceptionAttribute(&quot;ex&quot;);
    }
}
</code></pre>
<h2 id="拦截器">拦截器</h2>
<h3 id="方式一-3">方式一</h3>
<pre><code class="language-java">public class FirstInterceptor implements HandlerInterceptor {    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(FirstInterceptor.class + &quot; -&gt; preHandle&quot;);        return true;    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        System.out.println(FirstInterceptor.class + &quot; -&gt; postHandle&quot;);    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        System.out.println(FirstInterceptor.class + &quot; -&gt; afterCompletion&quot;);    }}
</code></pre>
<h3 id="方式二-3">方式二</h3>
<pre><code class="language-java">public class ThirdInterceptor implements WebRequestInterceptor {    @Override    public void preHandle(WebRequest request) throws Exception {        System.out.println(ThirdInterceptor.class + &quot; -&gt; preHandle&quot;);    }    @Override    public void postHandle(WebRequest request, ModelMap model) throws Exception {        System.out.println(ThirdInterceptor.class + &quot; -&gt; postHandle&quot;);    }    @Override    public void afterCompletion(WebRequest request, Exception ex) throws Exception {        System.out.println(ThirdInterceptor.class + &quot; -&gt; afterCompletion&quot;);    }}
</code></pre>
<h3 id="生效">生效</h3>
<pre><code class="language-java">@EnableWebMvc@ComponentScan(        basePackages = {&quot;com.shyer.controller&quot;, &quot;com.shyer.exception&quot;})public class SpringMvcConfig implements WebMvcConfigurer {    /**     * 配置拦截器     */    @Override    public void addInterceptors(InterceptorRegistry registry) {        registry.addInterceptor(new FirstInterceptor()).addPathPatterns(&quot;/**&quot;);        registry.addInterceptor(new SecondInterceptor());        registry.addWebRequestInterceptor(new ThirdInterceptor());    }}
</code></pre>
<h2 id="静态资源处理">静态资源处理</h2>
<h3 id="配置">配置</h3>
<pre><code class="language-java">@EnableWebMvc@ComponentScan(        basePackages = {&quot;com.shyer.controller&quot;, &quot;com.shyer.exception&quot;})public class SpringMvcConfig implements WebMvcConfigurer {    /**     * 静态资源处理 default-servlet-handler     */    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {        configurer.enable();    }}
</code></pre>
<h2 id="视图解析器">视图解析器</h2>
<h3 id="html">html</h3>
<blockquote>
<p>这里使用的是thymeleaf模版引擎</p>
</blockquote>
<pre><code class="language-java">public class MyWebApplicationInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {    /**     * Spring配置     */    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() {        return new Class[]{SpringConfig.class};    }}
</code></pre>
<pre><code class="language-java">@EnableWebMvc@ComponentScan(        basePackages = {&quot;com.shyer.controller&quot;, &quot;com.shyer.exception&quot;})public class SpringMvcConfig implements WebMvcConfigurer {    /*****************************************************     ********************** 视图解析器 *********************     *****************************************************/    @Bean    public ITemplateResolver templateResolver() {        WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(webApplicationContext.getServletContext());        templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;);        templateResolver.setSuffix(&quot;.html&quot;);        templateResolver.setCharacterEncoding(&quot;UTF-8&quot;);        templateResolver.setTemplateMode(TemplateMode.HTML);        return templateResolver;    }    @Bean    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) {        SpringTemplateEngine templateEngine = new SpringTemplateEngine();        templateEngine.setTemplateResolver(templateResolver);        return templateEngine;    }    @Bean    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();        viewResolver.setCharacterEncoding(&quot;UTF-8&quot;);        viewResolver.setTemplateEngine(templateEngine);        return viewResolver;    }}
</code></pre>
<h2 id="视图控制器">视图控制器</h2>
<pre><code class="language-java">@EnableWebMvc@ComponentScan(        basePackages = {&quot;com.shyer.controller&quot;, &quot;com.shyer.exception&quot;})public class SpringMvcConfig implements WebMvcConfigurer {    /**     * 视图控制器     */    @Override    public void addViewControllers(ViewControllerRegistry registry) {        registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;);    }}
</code></pre>
<h2 id="文件上传解析器">文件上传解析器</h2>
<pre><code class="language-java">@EnableWebMvc@ComponentScan(        basePackages = {&quot;com.shyer.controller&quot;, &quot;com.shyer.exception&quot;})public class SpringMvcConfig implements WebMvcConfigurer {    /**     * 文件上传解析器     */    @Bean    public MultipartResolver multipartResolver() {        return new CommonsMultipartResolver();    }}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring完全注解式开发 - 01 - demo]]></title>
        <id>https://shyer31.github.io/post/spring-anno-01-demo/</id>
        <link href="https://shyer31.github.io/post/spring-anno-01-demo/">
        </link>
        <updated>2021-07-29T10:15:22.000Z</updated>
        <summary type="html"><![CDATA[<p>学完《Spring完全注解式开发-01》，来写个demo放到tomcat上跑一下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>学完《Spring完全注解式开发-01》，来写个demo放到tomcat上跑一下。</p>
<!--more-->
<h2 id="环境">环境</h2>
<ul>
<li>
<p>开发工具</p>
<p><code>IntelliJ IDEA</code></p>
</li>
<li>
<p>服务器</p>
<p><code>Tomcat 9</code></p>
</li>
</ul>
<h2 id="搭建">搭建</h2>
<h3 id="目录结构">目录结构</h3>
<figure data-type="image" tabindex="1"><img src="https://shyer31.github.io/post-images/1627553779285.png" alt="" loading="lazy"></figure>
<h3 id="spring配置">Spring配置</h3>
<pre><code class="language-java">@ComponentScan(
        basePackages = {&quot;com.shyer&quot;},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION,  classes = {Controller.class})
        }
)
public class SpringConfig {
}
</code></pre>
<p>这里没有加<code>@Configuration</code>，待会说明。</p>
<h3 id="springmvc配置">SpringMVC配置</h3>
<pre><code class="language-java">@EnableWebMvc
@ComponentScan(
        basePackages = {&quot;com.shyer&quot;},
        includeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})
        },
        useDefaultFilters = false
)
public class SpringMvcConfig {
}
</code></pre>
<p>这里没有加<code>@Configuration</code>，待会说明。</p>
<h3 id="web配置">Web配置</h3>
<pre><code class="language-java">public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }

    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{&quot;/&quot;};
    }
}
</code></pre>
<p>这个配置就相当于以前配置<code>web.xml</code>了，将<code>Spring</code>和<code>SpringMVC</code>的配置和<code>servlet</code>结合起来，在项目启动的时候进行初始化。因为我们将配置交给了servlet管理了，所以<code>@Configuration</code>在上面是可以不加的。</p>
<p>另外我们这里只是继承了<code>AbstractAnnotationConfigDispatcherServletInitializer</code>就可以了，不再像以前那样配置web.xml了，我们的demo里也是没有web.xml的，根本原因就是servlet不知道啥时候起用起了<code>SPI</code>了，servlet对外提供了<code>ServletContainerInitializer</code>这个SPI接口，Spring的<code>SpringServletContainerInitializer</code>实现了该接口，并提供了<code>WebApplicationInitializer</code>接口供Spring使用者配置，而<code>AbstractAnnotationConfigDispatcherServletInitializer</code>就是<code>WebApplicationInitializer</code>的实现。</p>
<h3 id="测试代码">测试代码</h3>
<pre><code class="language-java">@RestController
public class HelloController {
    @Autowired
    private HelloService helloService;

    @RequestMapping(&quot;/hello&quot;)
    public String hello() {
        return helloService.hello();
    }
}


@Service
public class HelloService {
    public String hello() {
        return &quot;Hello World&quot;;
    }
}
</code></pre>
<p>部署到tomcat中，运行页面访问就行了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring完全注解式开发 - 01]]></title>
        <id>https://shyer31.github.io/post/spring-anno-01/</id>
        <link href="https://shyer31.github.io/post/spring-anno-01/">
        </link>
        <updated>2021-07-29T09:09:14.000Z</updated>
        <summary type="html"><![CDATA[<p>基于Spring5的开发学习，因为个人喜好，不用传统的<code>xml</code>配置方式，而是使用<code>Annotation-based</code>方式进行配置开发。</p>
]]></summary>
        <content type="html"><![CDATA[<p>基于Spring5的开发学习，因为个人喜好，不用传统的<code>xml</code>配置方式，而是使用<code>Annotation-based</code>方式进行配置开发。</p>
<!--more-->
<h2 id="spring配置类">Spring配置类</h2>
<h3 id="基本配置">基本配置</h3>
<ul>
<li>
<p>新建类<code>SpringConfig</code>作为<code>Spring</code>的配置</p>
<pre><code class="language-java">@Configuration
public class SpringConfig {
}
</code></pre>
</li>
<li>
<p>测试</p>
<p><strong>测试代码</strong></p>
<pre><code class="language-java">@Test
public void test01() {
  // 使用AnnotationConfigApplicationContext，也就是注解配置的应用上下文
  ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
  Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);
}
</code></pre>
<p><strong>测试结果</strong></p>
<pre><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
springConfig
</code></pre>
<p>可以看到spring容器已经扫描到了bean，并放入容器了。因为<code>@Configuration</code>这个注解本身也是<code>@Component</code>所以也被纳入了Spring容器中。但此时，Spring容器并没有扫描我们自己的包，只是将自身的几个Bean纳入了IOC中。</p>
</li>
</ul>
<h3 id="包扫描">包扫描</h3>
<ul>
<li>
<p>为配置类增加<code>@ComponentScan</code>注解，并设置<code>basePackages</code>，这样Spring会对<code>basePackages</code>中的包进行扫描，并将所有的组件放到IOC容器中，包括<code>@Component</code>，<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>，<code>@Configuration</code></p>
<pre><code class="language-java">@Configuration
@ComponentScan(
        basePackages = {&quot;com.shyer&quot;}
)
public class SpringConfig {
}
</code></pre>
<p><code>@ComponentScan</code>的属性<code>includeFilters</code>和<code>excludeFilters</code>可以用来自定义扫描的组件。</p>
<ul>
<li>
<p><code>includeFilters</code>：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(
        basePackages = {&quot;com.shyer&quot;},
        includeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})
        },
        useDefaultFilters = false
)
public class SpringConfig {
}
</code></pre>
<p>就会只扫描<code>com.shyer</code>包下<code>@Controller</code>注解类，注意这里还要设置一下<code>useDefaultFilters</code>为<code>false</code>，因为默认的<code>Filter</code>就是会扫描所有组件的。</p>
<ul>
<li>
<p>测试</p>
<p>测试代码</p>
<pre><code class="language-java">/**
 目录结构(根目录: com.shyer)
  -- config
    |-- SpringConfig.java
  -- controller
    |-- HelloController.java（@RestController）
  -- service
    |-- HelloService.java（@Service）
   */
@Test
public void test01() {
    ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
    Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);
}
</code></pre>
<p>测试结果</p>
<pre><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
springConfig
helloController
</code></pre>
<p>可以看到，只扫描出了<code>HelloController</code>，<code>HelloService</code>没有扫描到。</p>
</li>
</ul>
</li>
<li>
<p><code>excludeFilters</code></p>
<pre><code class="language-java">@Configuration
@ComponentScan(
        basePackages = {&quot;com.shyer&quot;},
        excludeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION,  classes = {Controller.class})
        }
)
public class SpringConfig {
}
</code></pre>
<p>会扫描<code>com.shyer</code>包下的的所有组件（因为<code>useDefaultFilters</code> 默认为<code>true</code>），除了<code>@Controller</code>组件。</p>
<ul>
<li>
<p>测试</p>
<p>测试代码</p>
<pre><code class="language-java">/**
 目录结构(根目录: com.shyer)
  -- config
    |-- SpringConfig.java
  -- controller
    |-- HelloController.java（@RestController）
  -- service
    |-- HelloService.java（@Service）
   */
@Test
public void test01() {
    ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
    Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);
}
</code></pre>
<p>测试结果</p>
<pre><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
springConfig
helloService
</code></pre>
<p>可以看到，只扫描了<code>HelloService</code>。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>发散一小下</p>
<p><code>includeFilters</code>可以配置扫描组件，那可不可以扫描我自己写的注解用在的类呢，试一下：</p>
<pre><code class="language-java">/**
  目录结构(根目录: com.shyer)
    -- bean
      |-- MyAnno.java
      |-- MyTest.java
  */

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MyAnno {
}

@MyAnno
public class MyTest {
}
</code></pre>
<p>将注解<code>MyAnno</code>添加到<code>includeFilters</code>中：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(
        basePackages = {&quot;com.shyer&quot;},
        includeFilters = {
                @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class, MyAnno.class})
        },
        useDefaultFilters = false
)
public class SpringConfig {
}
</code></pre>
<ul>
<li>
<p>测试</p>
<pre><code class="language-java">@Test
public void test01() {
  ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
  Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);
}
</code></pre>
<p>输出结果：</p>
<pre><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
springConfig
myTest
helloController
</code></pre>
<p>可以看到，<code>MyTest</code>也被扫描进了IOC容器了</p>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原子类]]></title>
        <id>https://shyer31.github.io/post/atomics/</id>
        <link href="https://shyer31.github.io/post/atomics/">
        </link>
        <updated>2021-07-28T10:48:02.000Z</updated>
        <summary type="html"><![CDATA[<p>本文为学习汪文君《Java 高并发编程详解 - 深入理解并发核心库》的笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文为学习汪文君《Java 高并发编程详解 - 深入理解并发核心库》的笔记</p>
<!--more-->
<p>JDK1.5之前，为了确保在多线程下对某基本数据类型或引用类型数据运算的原子性，必须依赖<code>synchronized</code>关键字，JDK1.5之后，JDK官方为开发者提供了原子类型的工具集，比如<code>AtomicInteger</code>，<code>AtomicBoolean</code>等。这些原子类型都是Lock-Free及线程安全的。</p>
<p>其实通过测试对比，监控线程状态可以发现，原子类型比如<code>AtomicInteger</code>的线程基本处于<code>RUNNABLE</code>状态，没有<code>BLOCKED</code>状态，而<code>synchronized</code>关键字则相反，<code>BLOCKED</code>的状态占比很高。</p>
<h2 id="atomicinteger">AtomicInteger</h2>
<p><code>AtomicInteger</code>和<code>Integer</code>一样，都继承了<code>Number</code>类。</p>
<p><code>AtomicInteger</code>的内部有一个被<code>volatile</code>关键字修饰的成员变量<code>value</code>：</p>
<pre><code class="language-java">private volatile int value;
</code></pre>
<p><code>AtomicInteger</code>提供的所有原子操作方法都是针对该变量进行操作的。</p>
<ul>
<li>
<p>数字增操作</p>
<ul>
<li>
<p><code>int getAndIncrement()</code></p>
<p>返回当前<code>int</code>类型的<code>value</code>值，然后对<code>value</code>进行自增运算。</p>
<p>单线程效果同<code>value++</code></p>
</li>
<li>
<p><code>int incrementAndGet()</code></p>
<p>直接返回自增后的<code>value</code>。</p>
<p>单线程效果同<code>++value</code></p>
</li>
</ul>
</li>
<li>
<p>数字减操作</p>
<ul>
<li>
<p><code>int getAndDecrement()</code></p>
<p>返回当前<code>int</code>类型<code>value</code>值，然后对<code>value</code>进行自减运算。</p>
<p>单线程效果同<code>value--</code></p>
</li>
<li>
<p><code>int decrementAndGet()</code></p>
<p>直接返回自减后的<code>value</code>。</p>
<p>单线程效果同<code>--value</code></p>
</li>
</ul>
</li>
<li>
<p>数字更新操作</p>
<ul>
<li>
<p><code>boolean compareAndSet(int expect, int update)</code></p>
<p>原子性更新<code>value</code>的值，<code>expect</code>代表期望的当前<code>value</code>值，<code>update</code>代表需要设置的新值。</p>
<p>如果当前的<code>value</code>与<code>expect</code>相同，则设置<code>value</code>为<code>update</code>，返回<code>true</code>。</p>
<p>如果当前的<code>value</code>与<code>expect</code>不同，则不修改<code>value</code>的值，直接返回<code>false</code>。</p>
</li>
<li>
<p><code>int getAndAdd(int delta)</code></p>
<p>原子性更新<code>value</code>的值，更新后的<code>value</code>为<code>value</code>和<code>delta</code>的和，方法返回的是<code>value</code>更新前的值。</p>
</li>
<li>
<p><code>int addAndGet(int delta)</code></p>
<p>该方法与<code>getAndAdd(int delta)</code>一样，只不过返回的是<code>value</code>更新后的值。</p>
</li>
</ul>
</li>
<li>
<p>AtomicInteger与函数式接口</p>
<p>JDK1.8之后增加了函数式接口，<code>AtomicInteger</code>也提供了对函数式接口的支持。</p>
<ul>
<li>
<p><code>int getAndUpdate(IntUnaryOperator updateFunction)</code></p>
<p>原子性更新<code>value</code>的值，入参为<code>IntUnaryOperator</code>接口，返回值为<code>value</code>更新前的值。</p>
<p><code>IntUnaryOperator</code> :</p>
<pre><code class="language-java">@FunctionalInterface
public interface IntUnaryOperator {
    /**
     * Applies this operator to the given operand.
     *
     * @param operand the operand
     * @return the operator result
     */
    int applyAsInt(int operand);
}
</code></pre>
<p>使用示例 :</p>
<pre><code class="language-java">AtomicInteger ai = new AtomicInteger(10);
assert ai.getAndUpdate(x -&gt; x + 2) == 10;
assert ai.get() == 12;
</code></pre>
</li>
<li>
<p><code>int updateAndGet(IntUnaryOperator updateFunction)</code></p>
<p>与<code>int getAndUpdate(IntUnaryOperator updateFunction)</code>类似，只是返回值为<code>value</code>更新后的值。</p>
</li>
<li>
<p><code>int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction)</code></p>
<p>原子性更新<code>value</code>值，返回<code>value</code>更新前的值</p>
<pre><code class="language-java">AtomicInteger ai = new AtomicInteger(10);
// left = 10, right = 5
ai.getAndAccumulate(5, (left, right) -&gt; left + right - 1);
assert ai.get() == 14;
</code></pre>
</li>
<li>
<p><code>int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction)</code></p>
<p>与<code>int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction)</code>类似，只是返回<code>value</code>更新后的值。</p>
</li>
</ul>
</li>
<li>
<p>其他方法</p>
<ul>
<li>
<p><code>void set(int newValue)</code></p>
<p>修改<code>value</code>的值为<code>newValue</code></p>
</li>
<li>
<p><code>void lazySet(int newValue)</code></p>
<p><code>volatile</code>将<code>value</code>强制刷到主内存中，归功于<code>volatile</code>底层的内存屏障，它会在设置<code>value</code>的时候创建hanppens-before edges，而<code>lazySet</code>是通过<code>Unsafe</code>根据<code>value</code>初始化时计算出来的偏移量找到<code>value</code>的地址，然后调用本地方法进行修改，这样就不会创建hanppens-before edges，但也因此<code>lazySet</code>不能保证<code>value</code>的立即可见。PS：底层的东西其实还不太懂，后续研究，单独写一篇。</p>
<figure data-type="image" tabindex="1"><img src="https://shyer31.github.io/post-images/1627469432064.png" alt="" loading="lazy"></figure>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CountDownLatch和CyclicBarrier]]></title>
        <id>https://shyer31.github.io/post/countdownlatch/</id>
        <link href="https://shyer31.github.io/post/countdownlatch/">
        </link>
        <updated>2021-07-28T01:16:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="countdownlatch">CountDownLatch</h2>
<h2 id="cyclicbarrier">CyclicBarrier</h2>
]]></content>
    </entry>
</feed>